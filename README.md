# AuthService
## Терминология:
1)В фигурных скобках будут писаться переменные. Пример: {path}, {ip}.
2)Для ответа в виде ошибки используется связка переменных errorCode (int) и error (string). errorCode необходим для идентефикации ошибки без необходимости сравнивать строки, а error - это текст ошибки для последующего вывода/обработки.

Функциональные возможности
    <ol>
    <li>Регистрация
        <ol>
            <li>Handler endpoint "{ip}:{port}/register"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "login":"",
                    "password":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                "error":"",
                "errorCode":0
                }
                ```
            </li>
            <li>Возвращаемые ошибки: ErrUserAlreadyExists,ErrTooShortLoginOrPassword, ErrServiceInternal, ErrInvalidInput</li>
            <li>Вариант использования - регистрация пользователя по логину и паролю.</li>
        </ol>
    </li> 
    <li>Аутентификация
        <ol>
            <li>Handler endpoint "{ip}:{port}/authenticate"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "login":"",
                    "password":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                    "error":"",
                    "errorCode":0,
                    "otpEnabled":false,
                    "intermediateToken:"",
                    "authInfo":{
                        "accessToken":"",
                        "refreshToken":"",
                    }
                }
                ```
            </li>
            <li>Возвращаемые ошибки: ErrUserNotExists,ErrTooShortLoginOrPassword, ErrServiceInternal, ErrInvalidInput</li>
            <li>Вариант использования - отправка логина и пароля, при корректности которых происходит либо получение токена для доступа к сервисам и токена для обновления токенов, в случае если для пользователя отключена двухфакторная аутентификация, либо отправляется otpEnabled = true и промежуточный токен, который необходим для продолжения аутентификации с помощью {ip}:{port}/authenticate/continue</li>
        </ol>
    </li>
    <li>Продолжение аутентификации при использовании otp
        <ol>
            <li>Handler endpoint "{ip}:{port}/authenticate/continue"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "intermediateToken":"",
                    "otpCode":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                    "error":"",
                    "errorCode":0,
                    "authInfo":{
                        "accessToken":"",
                        "refreshToken":"",
                    }
                }
                ```
            </li>
            <li>Возвращаемые ошибки: ErrInvalidOtp, ErrInvalidIntermediateToken, ErrExpiredIntermediateToken, ErrServiceInternal, ErrInvalidInput</li>
            <li>
                Вариант использования - после попытки аутентификации, пользователь отправляет промежуточный токен и код из приложения аутентификации. Если они валидны, то в ответ получает токен доступа к сервисам и токен для обновления токенов.
            </li>
        </ol>
    </li>
    <li>Авторизация
        <ol>
            <li>Handler endpoint "{ip}:{port}/authorize"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "accessToken":"",
                    "requiredRoleId":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                "userId":"",
                "error":"",
                "errorCode":0
                }
                ```
            </li>
            <li>Возвращаемые ошибки: ErrUserNotExists, ErrExpiredAccessToken, ErrInvalidAccessToken, ErrRoleHasNoAccess, ErrServiceInternal, ErrInvalidInput</li>
            <li>Вариант использования - отправка токена доступа полученного ранее, и необходимой для действия роли и проверка валидности токена,
            с отправкой uuid, если всё успешно и пустого uuid и ошибки, если токен не валиден.</li>
        </ol>
    </li>
    <li>Обновление токенов
        <ol>
            <li>Handler endpoint "{ip}:{port}/refresh"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "accessToken":"",
                    "refreshToken":"",
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                    "accessToken":"",
                    "refreshToken":"",
                    "error":"",
                    "errorCode":0
                }
                ```
            </li>
            <li>Возвращаемые ошибки: ErrExpiredRefreshToken, ErrInvalidRefreshToken, ErrInvalidAccessToken, ErrUserNotExists, ErrServiceInternal, ErrInvalidInput</li>
            <li>Вариант использования - если токен доступа истек, но в остальных аспектах валиден, то клиент может отправить запрос и получить новые токены. 
            Токены для обновления ходят парой, т.к. refresh токен привязан к access токену. В ответ отправляются новые токены.</li>
        </ol>
    </li>
    <li>Включение otp для пользователя
        <ol>
            <li>Handler endpoint "{ip}:{port}/otp/enable"</li>
            <li>
                Модель api: json. Формат: тело запроса не читается. Однако необходимо наличие заголовка запроса Authorization в формате: "Bearer {accessToken}"
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                    "error":"",
                    "errorCode":0,
                    "otpKey":"",
                    "otpUrl":"",
                }
                ```
            </li>
            <li>Возвращаемые ошибки: ErrOtpAlreadyEnabled, ErrUserNotExists, ErrServiceInternal, ErrWrongAuthorizeMethod</li>
            <li>Вариант использования - если аутентифицированный пользователь захотел включить двухфакторную аутентификацию для своего аккаунта, то он отправляет пустой запрос со своим токеном доступа в заголовке auhtorize. В ответ он получает ключ otp, для ручного ввода в аутентификатор и ссылку, которую можно преобразовать в qr код для быстрого добавления кода в аутентификатор</li>
        </ol>
    </li>
    <li>Выключение otp для пользователя
        <ol>
            <li>Handler endpoint "{ip}:{port}/otp/disable"</li>
            <li>
                Модель api: json. Формат: тело запроса не читается. Однако необходимо наличие заголовка запроса Authorization в формате: "Bearer {accessToken}"
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                    "error":"",
                    "errorCode":0,
                }
                ```
            </li>
            <li>Возвращаемые ошибки: ErrUserNotExists, ErrOtpAlreadyDisabled, ErrServiceIntenal, ErrWrongAuthorizeMethod</li>
            <li>Вариант использования - если аутентифицированный пользователь захотел выключить двухфакторную аутентификацию для своего аккаунта, то он отправляет пустой запрос со своим токеном доступа в заголовке auhtorize. В случае успеха ему отправляется error="" и errorCode=0</li>
        </ol>
    </li>
    </ol>
Для всех запросов необходим заголовок Content-Type=application/json
Во всех случаях в ответе имеются поля error и errorCode, которые предназначены для обработки ошибок на стороне клиента. В случае корректной работы отправляется error="" и errorCode=0. В случае неудачи по коду можно будет определить тип ошибки, например истекший токен или не валидный токен. Также есть одна ошибка обозначающая некорректную работу сервера, которая возвращается при неожиданной ошибке в процессе обработки запроса. Все коды ошибок смотрите в пункте пользовательские ошибки и их коды.
## База данных:
Если таблиц нет, то они создаются запросом (файлы находится в папке с миграциями и имеет название user_storage_up.sql и roles_storage_up.sql):
```
create table if not exists users (
    UserId text PRIMARY KEY,
    Login text UNIQUE,
    Password text,
    OtpEnabled boolean,
    OtpKey text,
    RoleId bigserial REFERENCES roles (RoleId)
);
```
```
create table if not exists roles (
    RoleId bigserial PRIMARY KEY,
    RoleName text UNIQUE
);
```
### Таблица Users:
UserId - это UUID, который используется как внешний ключ, который возвращается при авторизации. С помощью него сервисы, которым необходимо авторизовать пользователя привязывают свои данные к модели пользователя.
Login и Password - это поля для регистрации и аутентификации. RoleId - внешний ключ для связи с таблицой ролей. OtpEnabled - логическая переменная, говорящая включена ли двухфакторная аутентификация для пользователя. OtpKey - ключ для генерации кода двухфакторной аутентификации для сравнения на стороне сервера.

### Таблица Roles
RoleId - число идентефикатор роли. RoleName - имя роли (для понимания людьми).

На данный момент используется база данных postgresql, для нее написан provider, реализующий интерфейс UserStorage и RolesStorage.

## Архитектура проекта
Проект выполнен с использованием луковичной архитектуры. Самая высокоуровневая структура - это LogicProvider. Он является основной логикой проекта. Зависит от шести интерфейсов: UserStorage - хранилище пользователей, предоставляющее методы CRUD; RolesStorage - хранилище ролей, предоставляющее методы CRUD; PasswordHasher - хэшер паролей, предоставляющий методы хэширования и сравнения паролей; UUIDProvider - интерфейс предоставляющий доступ к генерации UUID; TokensProvider - интерфейс предоставляющий доступ к генерации и валидации access и refresh токенов; OtpGenerator - интерфейс предоставляющий доступ к генерации otp (используется для двухфакторной аутентификации).

Уровнем ниже идет CasesProvider. Он является прослойкой, которая отвечает за проверку полей и отклонение всех запросов по истечению контекста. Зависит от LogicProvider, интерфейса UseCasesConfig - интерфейсу предоставляющим методы чтения параметров для проверки данных ввода и от интерфейса логгирования предоставляющий доступ к логгированию в несколько источников.

Уровнем ниже идёт API, который использует CasesProvider. Задача слоя API десериализовать данные в аргументы для методов CasesProvider, а также сериализовать данные ответа. На данный момент реализованы методы API для фреймворка Fiber.

Функция main инициализирует все зависимости, и запускает API.

## Развертывание проекта
Для развертывания web сервера используется Docker. При развертывании необходимо прокинуть в контейнер порт. Внешний порт может быть любым но внутренний только 8080. Для развертывания базы данных можно также использовать Docker, для чего написан конфиг в Docker-compose.

## Тестирование
На данный момент написаны тесты для модуля CasesProvider без использования otp. Планируется написание интеграционных тестов.

## Структура конфига
```
{
	"organizationName":"",
	
    "apiPort":"8080",

	"minLoginLen":5,
	"minPasswordLen":5,

	"accessTokenKey":"",
	"accessTokenLifeTime":60,

	"refreshTokenKey":"",
    "refreshTokenLifeTime":24,
	"accessPartLen":5,

	"intermediateTokenKey":"",
	"intermediateTokenLifetime":5,

	"postgresConfig":{
		"login":"some_user",
		"password":"some_password",
		"ip":"db",
		"port":"5432"
	},
	"migrationsPath":"./migrations/postgres",
	"roles":[{
		"roleId":1,
		"roleName":"root"
	},{
		"roleId":2,
		"roleName":"user"
	}],
	"defaultRoleId":2
}
```
Элементы конфига можно разделить на изменяемые и привязанные к развертыванию Docker контейнера.
Изменяемые:
<ol>
    <li>organizationName - переменная, которая используется при генерации ссылки для добавления otp в аутентификатор (отображается в аутентификаторе)</li>
    <li>minLoginLen - минимальная длина логина проверяемая во всех методах запрашивающих логин.</li>
    <li>minPasswordLen - минимальная длина пароля проверяемая во всех методах запрашивающих пароль.</li>
    <li>accessTokenKey - ключ, использующийся для шифрования и валидации access токена.</li>
    <li>accessTokenLifeTime - время жизни (в минутах) access токена.</li>
    <li>refreshTokenKey - ключ, использующийся для шифрования и валидации refresh токена.</li>
    <li>refreshTokenLifeTime - время жизни (в часах) refresh токена.</li>
    <li>accessPartLen - длина части токена используемая для связывания access и refresh токена</li>
    <li>intermediateTokenKey - ключ, использующийся для шифрования и валидации intermediate токена</li>
    <li>intermediateTokenLifeTime - время жизни (в минутах) intermediate токена</li>
    <li>postgresConfig - конфиг для взаимодействия с postgres. Этого поля может не быть в случае использования другой базы данных (однако пока что не написаны provider для других баз данных).
    <ol>
        <li>login - логин пользователя postgresql.</li>
        <li>password - пароль пользователя postgresql.</li>
        <li>ip - домен/ip сервера postgresql.</li>
        <li>port - порт сервера postgresql.</li>
    </ol>
    </li>
    <li>roles - массив ролей, которые будут действовать при работе сервера. По умолчанию добавлены 2 роли root и user.</li>
    <li>defaultRoleId - роль, которая выдается по умолчанию для регистрирующегося пользователя.</li>
</ol>
Привязанные к развертыванию Docker контейнера:
<ol>
    <li>apiPort - порт сервера, внутри Docker контейнера. В описании образа Dockerfile открывается через EXPOSE 8080</li>
    <li>migrationsPath - путь внутри Docker контейнера с необходимыми файлами миграций. Копируется из папки проекта.</li>
</ol>   

## Пользовательские ошибки и их коды
<ol>
    <li>ErrServiceInternal - ошибка, возвращаемая при неожиданной ошибке в работе сервера. Код - 1. </li>
    <li>ErrExpiredAccessToken - ошибка, возвращаемая при истечении срока действия токена доступа к сервисам. Код - 101</li>
    <li>ErrExpiredRefreshToken - ошибка, возвращаемая при истечении срока действия токена для обновления токенов. Код - 102 </li>
    <li>ErrExpiredIntermediateToken - ошибка, возвращаемая при истечении срока действия токена для продолжения аутентификации с помощью otp. Код - 103</li>
    <li>ErrInvalidPassword - внутренняя ошибка сигнализирующая при вводе неправильного пароля. Не возвращается в api, т.к. преобразуется в ErrInvalidLoginOrPassword. Код - 104</li>
    <li>ErrInvalidAccessToken - ошибка, возвращаемая при невалидности токена доступа к сервисам. Код - 105</li>
    <li>ErrInvalidRefreshToken - ошибка, возвращаемая при невалидности токена для обновления токенов. Код - 106 </li>
    <li>ErrInvalidIntermediateToken - ошибка возвращаемая при невалидности токена для продолжения аутентификации с помощью otp. Код - 107</li>
    <li>ErrUserAlreadyExists - ошибка возвращаемая, если запрошенный пользователь уже зарегистрирован в системе. Код - 108</li>
    <li>ErrUserNotExists - ошибка возвращаемая, если запрошенный пользователь не зарегистрирован. Код - 109</li>
    <li>ErrInvalidOtp - ошибка возвращаемая, если пришедший otp код не валиден в текущий промежуток времени. Код - 110</li>
    <li>ErrRoleHasNoAccess - ошибка возвращаемая, если пользователь не имеет прав для выполнения операции. Код - 111</li>
    <li>ErrRoleAlreadyExists - внутренняя ошибка сигнализирующая о том, что роль уже зарегистрирована в системе. Не возвращается в api. Код - 112</li>
    <li>ErrRoleNotExists - ошибка возвращаемая, если запрошенная роль не зарегистрирована в системе. Код - 113</li>
    <li>ErrOtpAlreadyEnabled - ошибка возвращаемая, если для запрошенного пользователя уже включена двухфакторная аутентификация. Код - 114</li>
    <li>ErrOtpAlreadyDisabled - ошибка возвращаемая, если для запрошенного пользователя уже выключена двухфакторная аутентификация</li>
    <li>ErrInvalidLoginOrPassword - ошибка возвращаемая, если логин или пароль введенные пользователем при аутентификации не правильные. Код - 201</li>
    <li>ErrTooShortLoginOrPassword - ошибка возвращаемая, если введенные логин или пароль пользователя слишком короктие. Код - 202</li>
    <li>ErrInvalidInput - ошибка возвращаемая, когда не получилось прочитать ввод пользователя. Код - 301 </li>
    <li>ErrWrongAuthorizeMethod - ошибка возвращаемая, когда метод авторизации не соответствует выбранному системой (В данном случае заголовок Authorization не существует или не соответствует формату "Bearer {accessToken}"). Код - 302</li>
</ol>