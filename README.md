# AuthService
## Терминология:
1)В фигурных скобках будут писаться переменные. Пример: {path}, {ip}.
2)Для ответа в виде ошибки используется связка переменных errorCode (int) и error (string). errorCode необходим для идентефикации ошибки без необходимости сравнивать строки, а error - это текст ошибки для последующего вывода/обработки.

Функциональные возможности
    <ol>
    <li>Регистрация
        <ol>
            <li>Handler endpoint "{ip}:{port}/register"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "login":"",
                    "password":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                "error":"",
                "errorCode":0
                }
                ```
            </li>
            <li>Вариант использования - регистрация пользователя по логину и паролю.</li>
        </ol>
    </li> 
    <li>Аутентификация
        <ol>
            <li>Handler endpoint "{ip}:{port}/authenticate"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "login":"",
                    "password":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                    "error":"",
                    "errorCode":0,
                    "accessToken":"",
                    "refreshToken":"",
                }
                ```
            </li>
            <li>Вариант использования - отправка логина и пароля, и получения токена для доступа к сервисам и токена для обновления токенов.</li>
        </ol>
    </li>
    <li>Авторизация
        <ol>
            <li>Handler endpoint "{ip}:{port}/authorize"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "accessToken":"",
                    "login":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                "uuid":"",
                "error":"",
                "errorCode":0
                }
                ```
            </li>
            <li>Вариант использования - отправка токена доступа полученного ранее, и логина на имя которого был выписан токен и проверка валидности токена,
            с отправкой uuid, если всё успешно и пустого uuid и ошибки, если токен не валиден.</li>
        </ol>
    </li>
    <li>Обновление токенов
        <ol>
            <li>Handler endpoint "{ip}:{port}/refresh"</li>
            <li>
                Модель api: json. Формат:
                ```
                {
                    "accessToken":"",
                    "refreshToken":"",
                    "login":""
                }
                ```
            </li>
            <li>
                Модель ответа: json. Формат:
                ```
                {
                    "accessToken":"",
                    "refreshToken":"",
                    "error":"",
                    "errorCode":0
                }
                ```
            </li>
            <li>Вариант использования - если токен доступа истек, но в остальных аспектах валиден, то клиент может отправить запрос и получить новые токены. 
            Токены для обновления ходят парой, т.к. refresh токен привязан к access токену. В ответ отправляются новые токены.</li>
        </ol>
    </li>
    </ol>

## База данных:
Если таблицы нет, то она создаётся запросом (файл находится в папке с миграциями и имеет название user_storage_up.sql):
```
create table if not exists users (
    UserId text PRIMARY KEY,
    Login text UNIQUE,
    Password text
);
```
UserId - это UUID, который используется как внешний ключ, который возвращается при авторизации. С помощью него сервисы, которым необходимо авторизовать пользователя привязывают свои данные к модели пользователя.
Login и Password - это поля для регистрации.
На данный момент используется база данных postgresql, для нее написан provider, реализующий интерфейс UserStorage.

## Архитектура проекта
Смотрите файл "AuthService architecture.vpd"
Проект выполнен с использованием луковичной архитектуры. Самая высокоуровневая структура - это LogicProvider. Он является основной логикой проекта. Зависит от четырёх интерфейсов: UserStorage - хранилище пользователей, предоставляющее методы CRUD; PasswordHasher - хэшер паролей, предоставляющий методы хэширования и сравнения паролей; UUIDProvider - интерфейс предоставляющий доступ к генерации UUID; TokensProvider - интерфейс предоставляющий доступ к генерации и валидации access и refresh токенов.

Уровнем ниже идет CasesProvider. Он является прослойкой, которая отвечает за проверку полей и отклонение всех запросов по истечению контекста. Зависит от LogicProvider и интерфейса UseCasesConfig - интерфейсу предоставляющим методы чтения параметров для проверки данных ввода.

Уровнем ниже идёт API, который использует CasesProvider. Задача слоя API десериализовать данные в аргументы для методов CasesProvider, а также сериализовать данные ответа. На данный момент реализованы методы API для фреймворка Fiber.

Функция main инициализирует все зависимости, и запускает API.

## Развертывание проекта
Для развертывания web сервера используется Docker. При развертывании необходимо прокинуть в контейнер порт. Внешний порт может быть любым но внутренний только 8080. Для развертывания базы данных можно также использовать Docker, для чего написан конфиг в Docker-compose.

## Тестирование
На данный момент написаны тесты для модуля CasesProvider. Планируется написание интеграционных тестов.

## Структура конфига
```
{
    "apiPort":"8080",

	"minLoginLen":0,
	"minPasswordLen":0,

	"accessTokenKey":"",
	"accessTokenLifeTime":0,

	"refreshTokenKey":"",
    "refreshTokenLifeTime":0,
    
	"accessPartLen":0,

	"postgresConfig":{
		"login":"some_user",
		"password":"some_password",
		"ip":"db",
		"port":"5432"
	},
	"migrationsPath":"./migrations/postgres"
}
```
Элементы конфига можно разделить на изменяемые и привязанные к развертыванию Docker контейнера.
Изменяемые:
<ol>
    <li>minLoginLen - минимальная длина логина проверяемая во всех методах запрашивающих логин.</li>
    <li>minPasswordLen - минимальная длина пароля проверяемая во всех методах запрашивающих пароль.</li>
    <li>accessTokenKey - ключ использующийся для шифрования и валидации access токена.</li>
    <li>accessTokenLifeTime - время жизни (в минутах) access токена.</li>
    <li>refreshTokenKey - ключ использующийся для шифрования и валидации refresh токена.</li>
    <li>refreshTokenLifeTime - время жизни (в часах) refresh токена.</li>
    <li>accessPartLen - длина части токена используемая для связывания access и refresh токена</li>
    <li>postgresConfig - конфиг для взаимодействия с postgres. Этого поля может не быть в случае использования другой базы данных (однако пока что не написаны provider для других баз данных).
    <ol>
        <li>login - логин пользователя postgresql.</li>
        <li>password - пароль пользователя postgresql.</li>
        <li>ip - домен/ip сервера postgresql.</li>
        <li>port - порт сервера postgresql.</li>
    </ol>
    </li>
</ol>
Привязанные к развертыванию Docker контейнера:
<ol>
    <li>apiPort - порт сервера, внутри Docker контейнера. В описании образа Dockerfile открывается через EXPOSE 8080</li>
    <li>migrationsPath - путь внутри Docker контейнера с необходимыми файлами миграций. Копируется из папки проекта.</li>
</ol>